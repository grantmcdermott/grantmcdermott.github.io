<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Grant McDermott">
<meta name="dcterms.date" content="2021-06-24">
<meta name="description" content="Better, faster, stronger.">

<title>Efficient simulations in R – Grant R. McDermott</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/iconify-2.1.0/iconify-icon.min.js"></script>
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-76482472-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Efficient simulations in R – Grant R. McDermott">
<meta property="og:description" content="Better, faster, stronger.">
<meta property="og:site_name" content="Grant R. McDermott">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Grant R. McDermott</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://grantmcdermott.com/vita/mcdermott-vita.pdf"> 
<span class="menu-text">Vita</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/grantmcdermott"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://bsky.app/profile/gmcd.bsky.social"> 
<span class="menu-text"><iconify-icon role="img" inline="" icon="fa6-brands:bluesky" aria-label="Icon bluesky from fa6-brands Iconify.design set." title="Icon bluesky from fa6-brands Iconify.design set."></iconify-icon></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Efficient simulations in R</h1>
                  <div>
        <div class="description">
          Better, faster, stronger.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">R</div>
                <div class="quarto-category">econometrics</div>
                <div class="quarto-category">data science</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Grant McDermott </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 24, 2021</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#motivation" id="toc-motivation" class="nav-link active" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#our-example-interaction-effects-in-panel-models" id="toc-our-example-interaction-effects-in-panel-models" class="nav-link" data-scroll-target="#our-example-interaction-effects-in-panel-models">Our example: Interaction effects in panel models</a>
  <ul class="collapse">
  <li><a href="#data-generating-function" id="toc-data-generating-function" class="nav-link" data-scroll-target="#data-generating-function">Data generating function</a></li>
  </ul></li>
  <li><a href="#principle-1-trim-the-fat" id="toc-principle-1-trim-the-fat" class="nav-link" data-scroll-target="#principle-1-trim-the-fat">Principle 1: Trim the fat</a></li>
  <li><a href="#principle-2-generate-your-data-once" id="toc-principle-2-generate-your-data-once" class="nav-link" data-scroll-target="#principle-2-generate-your-data-once">Principle 2: Generate your data once</a></li>
  <li><a href="#principle-3-go-parallel-or-nest" id="toc-principle-3-go-parallel-or-nest" class="nav-link" data-scroll-target="#principle-3-go-parallel-or-nest">Principle 3: Go parallel or nest</a></li>
  <li><a href="#principle-4-use-matrices-for-an-extra-edge" id="toc-principle-4-use-matrices-for-an-extra-edge" class="nav-link" data-scroll-target="#principle-4-use-matrices-for-an-extra-edge">Principle 4: Use matrices for an extra edge</a></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting it all together</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>Being able to code up efficient simulations is one of the most useful skills that you can develop as a social (data) scientist. Unfortunately, it’s also something that’s rarely taught in universities or textbooks.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> This post will cover some general principles that I’ve adopted for writing fast simulation code in R.</p>
<p>I should clarify that the type of simulations that I, personally, am most interested in are related to <em>econometrics</em>. For example, Monte Carlo experiments to better understand when a particular estimator or regression specification does well (or poorly). The guidelines here should be considered accordingly and might not map well on to other domains (e.g.&nbsp;agent-based models or numerical computation). {: .notice–info}</p>
</section>
<section id="our-example-interaction-effects-in-panel-models" class="level2">
<h2 class="anchored" data-anchor-id="our-example-interaction-effects-in-panel-models">Our example: Interaction effects in panel models</h2>
<p>I’m going to illustrate by replicating a simulation result in a paper that I really like: “Interaction effects in econometrics” by <a href="https://www.uh.edu/~bsorense/Interaction_EE.pdf">Balli &amp; Sørensen (2013)</a> (hereafter, <strong>BS13</strong>).</p>
<p>BS13 does various things, but one result in particular has had a big impact on my own research. They show that empirical researchers working with panel data are well advised to demean any (continuous) variables that are going to be interacted in a regression. That is, rather than estimating the model in “level” terms…</p>
<p><span class="math display">\[Y_{it} = \mu_i + \beta_1X1_{it} + \beta_2X2_{it} + \beta_3X1_{it} \cdot X2_{it} + \epsilon_{it}\]</span></p>
<p>… you should estimate the “demeaned” version instead<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p><span class="math display">\[Y_{it} = \beta_0 + \beta_1 (X1_{it} - \overline{X1}_{i.}) + \beta_2 (X2_{it} - \overline{X2}_{i.}) + \beta_3(X1_{it} - \overline{X1}_{i.}) \cdot (X2_{it} - \overline{X2}_{i.}) + \epsilon_{it}\]</span></p>
<p>Here, <span class="math inline">\(\overline{X1}_{i.}\)</span> refers to mean value of variable <span class="math inline">\(X1\)</span> (e.g.&nbsp;GDP over time) for unit <span class="math inline">\(i\)</span> (e.g.&nbsp;country).</p>
<p>We’ll get to the simulations in a second, but BS13 describe the reasons for their recommendation in very intuitive terms. The super short version — again, you really should read the paper — is that the level model can pick up spurious trends in the case of varying slopes. The implications of this insight are fairly profound… if for no other reason that <em>so</em> many applied econometrics papers employ interaction terms in a panel setting.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Okay, so a potentially big deal. But let’s see a simulation and thereby get the ball rolling for this post. I’m going to run a simulation experiment that exactly mimics one in BS13 (see Table 3). We’ll create a fake dataset where the true interaction is ZERO. However, the slope coefficient of one of the parent terms varies by unit (here: country). If BS13 is right, then including an interaction term in our model could accidentally result in a spurious, non-zero coefficient on this interaction term. The exact model is</p>
<p><span class="math display">\[y_{it} = \alpha + x_{1,it} + 1.5x_{2,it} + \epsilon_{it}\]</span></p>
<section id="data-generating-function" class="level3">
<h3 class="anchored" data-anchor-id="data-generating-function">Data generating function</h3>
<p>It will prove convenient for me to create a function that generates an instance of the experimental dataset — i.e.&nbsp;corresponding to one simulation run — which is what you see in the code below. The exact details are not especially important. (I’m going to coerce the return object into a <strong>data.table</strong> instead of standard data frame, but I’ll get back to that later.) For now, just remember that the coefficient on any interaction term should be zero by design. I’ll preview the resulting dataset at the end of the code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="do">## Convenience function for generating our experimental panel data. Takes a </span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="do">## single argument: `sims` (i.e. how many simulation runs to do we want; defaults </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="do">## to 1).</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>gen_data <span class="ot">=</span> <span class="cf">function</span>(<span class="at">sims=</span><span class="dv">1</span>) {</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Total time periods in the the panel = 500</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  tt <span class="ot">=</span> <span class="dv">500</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">=</span> <span class="fu">rep</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>sims, <span class="at">each =</span> <span class="dv">10</span>), <span class="at">times =</span> <span class="dv">2</span>) <span class="do">## Repeat twice b/c we have two countries</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="do">## x1 covariates</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  x1_A <span class="ot">=</span> <span class="dv">1</span> <span class="sc">+</span> <span class="fu">rnorm</span>(tt<span class="sc">*</span>sims, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  x1_B <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">4</span> <span class="sc">+</span> <span class="fu">rnorm</span>(tt<span class="sc">*</span>sims, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Add second, nested x2 covariates for each country</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  x2_A <span class="ot">=</span> <span class="dv">1</span> <span class="sc">+</span> x1_A <span class="sc">+</span> <span class="fu">rnorm</span>(tt<span class="sc">*</span>sims, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  x2_B <span class="ot">=</span> <span class="dv">1</span> <span class="sc">+</span> x1_B <span class="sc">+</span> <span class="fu">rnorm</span>(tt<span class="sc">*</span>sims, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Outcomes (notice different slope coefs for x2_A and x2_B)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  y_A <span class="ot">=</span> x1_A <span class="sc">+</span> <span class="dv">1</span><span class="sc">*</span>x2_A <span class="sc">+</span> <span class="fu">rnorm</span>(tt<span class="sc">*</span>sims, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  y_B <span class="ot">=</span> x1_B <span class="sc">+</span> <span class="dv">2</span><span class="sc">*</span>x2_B <span class="sc">+</span> <span class="fu">rnorm</span>(tt<span class="sc">*</span>sims, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Combine in a data table (basically just an enhanced data frame)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  dat <span class="ot">=</span> </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">data.table</span>(</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      sim,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>      <span class="at">id =</span> <span class="fu">as.factor</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">'A'</span>, <span class="fu">length</span>(x1_A)), <span class="fu">rep</span>(<span class="st">'B'</span>, <span class="fu">length</span>(x1_B)))),</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>      <span class="at">x1 =</span> <span class="fu">c</span>(x1_A, x1_B),</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>      <span class="at">x2 =</span> <span class="fu">c</span>(x2_A, x2_B),</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>      <span class="at">y =</span> <span class="fu">c</span>(y_A, y_B)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Demeaned covariates (grouped by country and simulation)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  dat[, </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>      <span class="st">`</span><span class="at">:=</span><span class="st">`</span> (<span class="at">x1_dmean =</span> x1 <span class="sc">-</span> <span class="fu">mean</span>(x1),</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="at">x2_dmean =</span> x2 <span class="sc">-</span> <span class="fu">mean</span>(x2)),</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>      by <span class="ot">=</span> .(sim, id)][]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Optional set order i.t.o sims</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setorder</span>(dat, sim)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(dat)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="do">## Generate an instance of the data (using the default arguments)</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="fu">gen_data</span>()</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        sim     id            x1         x2          y    x1_dmean    x2_dmean
      &lt;int&gt; &lt;fctr&gt;         &lt;num&gt;      &lt;num&gt;      &lt;num&gt;       &lt;num&gt;       &lt;num&gt;
   1:     1      A  0.4395243534  0.4437256  0.3716463 -0.59506609 -1.61706557
   2:     1      A  0.7698225105  0.7298675  1.7366279 -0.26476794 -1.33092373
   3:     1      A  2.5587083141  3.5407281  5.5578472  1.52411787  1.47993688
   4:     1      A  1.0705083914  1.9383333  4.2280693  0.03591794 -0.12245794
   5:     1      A  1.1292877352 -0.4200550  0.8833686  0.09469729 -2.48084624
  ---                                                                         
 996:     1      B  0.1600248030  1.2366685  3.6943280 -0.08764048 -0.06972657
 997:     1      B  1.3205160368  2.5756808  6.0263720  1.07285075  1.26928576
 998:     1      B -1.1011003857  0.1763464 -1.1775877 -1.34876567 -1.13004861
 999:     1      B -0.2726166972  1.2642393  3.4448738 -0.52028198 -0.04215572
1000:     1      B  0.0008093222  0.5403238  1.9157509 -0.24685596 -0.76607128</code></pre>
</div>
</div>
<p>Let’s run some regressions on one simulated draw of our dataset. Since this is a panel model, I’ll use the (incredible) <strong>fixest</strong> package to control for country (“id”) fixed-effects.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fixest)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>mod_level <span class="ot">=</span> <span class="fu">feols</span>(y <span class="sc">~</span> x1 <span class="sc">*</span> x2 <span class="sc">|</span> id, d)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>mod_dmean <span class="ot">=</span> <span class="fu">feols</span>(y <span class="sc">~</span> x1_dmean <span class="sc">*</span> x2_dmean <span class="sc">|</span> id, d)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">etable</span>(mod_level, mod_dmean, <span class="at">se  =</span> <span class="st">'standard'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                              mod_level          mod_dmean
Dependent Var.:                       y                  y
                                                          
x1                    1.195*** (0.0650)                   
x2                    1.638*** (0.0394)                   
x1 x x2             -0.1373*** (0.0187)                   
x1_dmean                                0.9544*** (0.0577)
x2_dmean                                 1.556*** (0.0388)
x1_dmean x x2_dmean                        0.0199 (0.0213)
Fixed-Effects:      ------------------- ------------------
id                                  Yes                Yes
___________________ ___________________ __________________
S.E. type                           IID                IID
Observations                      1,000              1,000
R2                              0.86768            0.86062
Within R2                       0.86761            0.86055
---
Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<p>Well, there you have it. The “level” model spuriously yields a statistically significant coefficient on the interaction term. In comparison, the “demeaned” version avoids this trap and also appears to have better estimated the parent term coefficients.</p>
<p>Cool. But to <em>really</em> be sure, we should repeat our simulation many times. (BS13 do it 20,000 times…) And, so, we now move on to the main purpose of this post: How do we write simulation code that efficiently completes tens of thousands of runs? Here follow some key principles that I try to keep in mind.</p>
</section>
</section>
<section id="principle-1-trim-the-fat" class="level2">
<h2 class="anchored" data-anchor-id="principle-1-trim-the-fat">Principle 1: Trim the fat</h2>
<p><strong>Subtitle: <code>lm.fit()</code> is your friend</strong></p>
<p>The first key principle for writing efficient simulation code is to trim the fat as much as possible. Even small differences start to add up once you’re repeating operations tens of thousands of times. For example, does it really make sense to use <code>fixest::feols()</code> for this example data? As much as I am a huge <strong>fixest</strong> stan, in this case I have to say… no. The package is optimised for high-dimensional fixed-effects, clustered errors, etc. Our toy dataset contains just one fixed-effect (comprising two levels) and we are ultimately only interested in extracting a single coefficient for our simulation. We don’t even need to save the standard errors. Most of <strong>fixest</strong>’s extra features are essentially wasted. We could probably do better just by using a simple <code>lm()</code> call and specifying the country fixed-effect (“id”) as a factor.</p>
<p>However, <code>lm()</code> objects still contain quite a lot of information (and invoke extra steps) that we don’t need. We can simplify things even further by directly using the fitting function that <code>lm</code> calls underneath the hood. Specifically, the <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/lmfit.html"><strong><code>lm.fit()</code></strong></a> function. This requires a slightly different way of writing our regression model — closer to matrix form — but yields considerable speed gains. Here’s a benchmark to demonstrate.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">feols  =</span> <span class="fu">feols</span>(y <span class="sc">~</span> x1_dmean <span class="sc">*</span> x2_dmean <span class="sc">|</span> id, d),</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">lm     =</span> <span class="fu">lm</span>(y <span class="sc">~</span> x1_dmean <span class="sc">*</span> x2_dmean <span class="sc">+</span> id, d),</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">lm.fit =</span> <span class="fu">lm.fit</span>(<span class="fu">cbind</span>(<span class="dv">1</span>, d<span class="sc">$</span>x1_dmean, d<span class="sc">$</span>x2_dmean, d<span class="sc">$</span>x1_dmean<span class="sc">*</span>d<span class="sc">$</span>x2_dmean, d<span class="sc">$</span>id), d<span class="sc">$</span>y),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">times  =</span> <span class="dv">2</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Unit: microseconds
   expr      min       lq     mean   median       uq      max neval cld
  feols 4779.250 4779.250 4944.217 4944.217 5109.184 5109.184     2  a 
     lm  896.933  896.933 1628.575 1628.575 2360.217 2360.217     2   b
 lm.fit   93.579   93.579  115.151  115.151  136.723  136.723     2   b</code></pre>
</div>
</div>
<p>For this small dataset example, a regular <code>lm()</code> call is about five times faster than <code>feols()</code>… and <code>lm.fit()</code> is a further ten times faster still. Now, we’re talking microseconds here and the difference is not something you’d notice running a single regression. But… once you start running 20,000 of them, then those microseconds start to add up.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Final thing, just to prove that we’re getting the same coefficients:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(<span class="fu">lm.fit</span>(<span class="fu">cbind</span>(<span class="dv">1</span>, d<span class="sc">$</span>x1_dmean, d<span class="sc">$</span>x2_dmean, d<span class="sc">$</span>x1_dmean<span class="sc">*</span>d<span class="sc">$</span>x2_dmean, d<span class="sc">$</span>id), d<span class="sc">$</span>y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         x1          x2          x3          x4          x5 
 3.16116857  0.95435281  1.55596182  0.01993248 -0.14977947 </code></pre>
</div>
</div>
<p>The output is less visually appealing a regular regression summary, but we can see the interaction term coefficient of <code>0.01993247</code> in the order in which it appeared (i.e.&nbsp;“x4”). FWIW, you can also name the coefficients in the design matrix if you wanted to make it easier to reference a coefficient by name. This is what I’ll be doing in the full simulation right at the end.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(<span class="fu">lm.fit</span>(<span class="fu">cbind</span>(<span class="st">'intercept'</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">'x1'</span> <span class="ot">=</span> d<span class="sc">$</span>x1_dmean, <span class="st">'x2'</span> <span class="ot">=</span> d<span class="sc">$</span>x2_dmean, <span class="st">'x1:x2'</span> <span class="ot">=</span> d<span class="sc">$</span>x1_dmean<span class="sc">*</span>d<span class="sc">$</span>x2_dmean, <span class="st">'id'</span> <span class="ot">=</span> d<span class="sc">$</span>id), d<span class="sc">$</span>y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  intercept          x1          x2       x1:x2          id 
 3.16116857  0.95435281  1.55596182  0.01993248 -0.14977947 </code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>There is an even faster <code>.lm.fit</code> function (note the leading <code>.</code>). The same ideas carry over as with “regular” <code>lm.fit()</code>. See follow up post <a href="../efficient-simulations-r-base-remix">here</a>.</p>
</div>
</div>
</section>
<section id="principle-2-generate-your-data-once" class="level2">
<h2 class="anchored" data-anchor-id="principle-2-generate-your-data-once">Principle 2: Generate your data once</h2>
<p><strong>Subtitle: It’s much quicker to generate one large dataset than many small ones</strong></p>
<p>One common bottleneck I see in a lot of simulation code is generating a small dataset for each new run of a simulation. This is much less efficient that generating a single large dataset that you can either sample from during each iteration, or subset by a dedicated simulation ID. We’ll get to iteration next, but this second principle really stems from the same core idea: <em><a href="https://win-vector.com/2019/01/03/what-does-it-mean-to-write-vectorized-code-in-r/">vectorisation</a> in R is much faster than iteration</em>. Here’s a simple benchmark to illustrate, where we generate data for a 100 simulation runs. Note that the relative difference would keep growing as we added more simulations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">many_small =</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, gen_data),</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">one_big =</span> <span class="fu">gen_data</span>(<span class="dv">100</span>),</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">times =</span> <span class="dv">2</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Unit: milliseconds
       expr       min        lq       mean     median         uq        max
 many_small 1473.3100 1473.3100 1751.12735 1751.12735 2028.94469 2028.94469
    one_big   23.1516   23.1516   23.16008   23.16008   23.16856   23.16856
 neval cld
     2  a 
     2   b</code></pre>
</div>
</div>
</section>
<section id="principle-3-go-parallel-or-nest" class="level2">
<h2 class="anchored" data-anchor-id="principle-3-go-parallel-or-nest">Principle 3: Go parallel or nest</h2>
<p><strong>Subtitle: Let data.table and co. handle the heavy lifting</strong></p>
<p>The standard approach to coding up a simulation is to run everything as an iteration, either using a <code>for()</code> loop or an <code>lapply()</code> call. Experienced R programmers are probably reading this section right now and thinking, “Even better; run everything in parallel.” And it’s true. A Monte Carlo experiment like the one we’re doing here is ideally suited to parallel implementation, because each individual simulation run is independent. It’s a key reason why Monte Carlo experiments are such popular tools for teaching parallel programming concepts. (<a href="https://grantmcdermott.com/ds4e/parallel.html#example-2-bootstrapping">Guilty as charged</a>.)</p>
<p>But any type of explicit iteration — whether it is a <code>for()</code> loop or an <code>lapply()</code> call, or whether it is run sequentially or in parallel — runs up against the same problem as we saw in Principle 2. Specifically, it is slower than <a href="https://grantmcdermott.com/ds4e/funcs-intro.html#vectorisation">vectorisation</a>. So how can we run our simulations in vectorised fashion? Well, it turns out there is a pretty simple way that directly leverages Principle 2’s idea of generating one large dataset: We <em>nest</em> our simulations directly in our large <strong>data.table</strong> or <strong>tibble</strong>.</p>
<p>Hadley and Garret’s <em>R for Data Science</em> book has a nice <a href="https://r4ds.had.co.nz/many-models.html">chapter</a> on model nesting with tibbles, and then Vincent has a cool <a href="http://www.arelbundock.com/../datatable_nesting/">blog post</a> replicating the same workflow with data.table. But, really, the core idea is pretty simple: We can use the advanced data structure and functionality of tibbles or data.tables to run our simulations as grouped operations (i.e.&nbsp;by simulation ID). In other words, just like we can group a data frame and then collapse down to (say) mean values, we can also group a data frame and then run a regression on each subgroup.</p>
<p>Why might this be faster than explicit parallel iteration? Well, basically it boils down to the fact that data.tables and tibbles provide an enhanced structure for returning complex objects (including list columns) and their grouped operations are highly optimised to run in (implicit) parallel at the C++ level.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> The internal code of <strong>data.table</strong>, in particular, is just so insanely optimised that trying to beat it with some explicit parallel loop can be a <a href="https://grantmcdermott.com/ds4e/parallel.html#library-source-code">fool’s errand</a>.</p>
<p>Okay, so let’s see a benchmark. I’m going to compare three options for simulating 100 draws: 1) sequential iteration with <code>lapply()</code>, 2) explicit parallel iteration with <code>parallel::mclapply</code>, and 3) nested (implicit parallel) iteration. For the latter, I’m simply grouping my dataset by simulation ID and then leveraging data.table’s powerful <a href="https://rdatatable.gitlab.io/data.table/articles/datatable-sd-usage.html"><strong><code>.SD</code></strong></a> syntax.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> Note further than I’m going to run regular <code>lm()</code> calls rather than <code>lm.fit()</code> — see Principle 1 — because I want to keep things simple and familiar for the moment.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(parallel) <span class="do">## For parallel::mclapply</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="do">## Generate dataset with 1000 simulation draws</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="fu">gen_data</span>(<span class="dv">100</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">sequential =</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(d<span class="sc">$</span>sim), </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">function</span>(i) <span class="fu">coef</span>(<span class="fu">lm</span>(y <span class="sc">~</span> x1 <span class="sc">*</span> x2 <span class="sc">+</span> id, d[sim<span class="sc">==</span>i]))[<span class="st">'x1:x2'</span>]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>                        ),</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">parallel =</span> <span class="fu">mclapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(d<span class="sc">$</span>sim), </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">function</span>(i) <span class="fu">coef</span>(<span class="fu">lm</span>(y <span class="sc">~</span> x1 <span class="sc">*</span> x2 <span class="sc">+</span> id, d[sim<span class="sc">==</span>i]))[<span class="st">'x1:x2'</span>], </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>                        <span class="at">mc.cores =</span> <span class="fu">detectCores</span>()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>                        ),</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">nested =</span> d[, <span class="fu">coef</span>(<span class="fu">lm</span>(y <span class="sc">~</span> x1 <span class="sc">*</span> x2 <span class="sc">+</span> id, .SD))[<span class="st">'x1:x2'</span>], <span class="at">by =</span> sim],</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">times =</span> <span class="dv">2</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Unit: milliseconds
       expr       min        lq     mean   median       uq      max neval cld
 sequential 142.18928 142.18928 161.5120 161.5120 180.8346 180.8346     2   a
   parallel 126.91207 126.91207 128.9292 128.9292 130.9463 130.9463     2   a
     nested  99.18945  99.18945 101.9551 101.9551 104.7208 104.7208     2   a</code></pre>
</div>
</div>
<p>Okay, not a huge difference between the three options for this small benchmark. <del>But — trust me — the difference will grow for the full simulation where we’re comparing the level vs demeaned regressions with <code>lm.fit()</code>.</del> <em>UPDATE: Upon reflection, I’m not being quite fair to <code>mclapply()</code> here, because it is being penalised for overhead on a small example. But I definitely stand by my next point.</em> There are also some other reasons why relying on <strong>data.table</strong> will help us here. For example, <code>parallel::mclapply()</code> relies on forking, which is <a href="https://grantmcdermott.com/ds4e/parallel.html#forking-vs-sockets">only available</a> on Linux or Mac. Sure, you could use a different package like <strong>future.apply</strong> to provide a parallel backend (PSOCK) for Windows, but that’s going to be slower. Really, the bottom line is that we can outsource all of that parallel overhead to <strong>data.table</strong> and it will automatically handle everything at the C(++) level. Winning.</p>
</section>
<section id="principle-4-use-matrices-for-an-extra-edge" class="level2">
<h2 class="anchored" data-anchor-id="principle-4-use-matrices-for-an-extra-edge">Principle 4: Use matrices for an extra edge</h2>
<p><strong>Subtitle: Save your simulation from having to do extra conversion work</strong></p>
<p>The primary array format of empirical work is the data frame. It’s what we all use, really, so there’s no point expanding on that. (TL;DR data frames are just very convenient for humans to work with and reason about.) However, regressions are run on <em>matrices</em>. Which is to say that when you run a regression in R — and most other languages for that matter — behind the scenes your input data frame is first converted to an equivalent matrix before any computation gets done. Matrices have several features that make them “faster” to compute on than data frames. For example, every element must be of the same type (say, numeric). But let’s just agree that converting a data frame to a matrix requires at least some computational effort. Consider then what happens when we feed our <code>lm.fit()</code> function a pre-created design matrix, instead asking it to convert a bunch of data frame columns on the fly.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="fu">gen_data</span>()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">cbind</span>(<span class="at">intercept =</span> <span class="dv">1</span>, <span class="at">x1 =</span> d<span class="sc">$</span>x1_dmean, <span class="at">x2 =</span> d<span class="sc">$</span>x2_dmean, <span class="st">'x1:x2'</span> <span class="ot">=</span> d<span class="sc">$</span>x1_dmean<span class="sc">*</span>d<span class="sc">$</span>x2_dmean, <span class="at">id =</span> d<span class="sc">$</span>id)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">=</span> d<span class="sc">$</span>y</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">lm.fit =</span> <span class="fu">lm.fit</span>(<span class="fu">cbind</span>(<span class="dv">1</span>, d<span class="sc">$</span>x1_dmean, d<span class="sc">$</span>x2_dmean, d<span class="sc">$</span>x1_dmean<span class="sc">*</span>d<span class="sc">$</span>x2_dmean, d<span class="sc">$</span>id), d<span class="sc">$</span>y),</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">lm.fit_mat =</span> <span class="fu">lm.fit</span>(X, Y),</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">times  =</span> <span class="dv">5</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Unit: microseconds
       expr    min     lq     mean median     uq     max neval cld
     lm.fit 75.345 78.277 108.4792 81.008 84.877 222.889     5   a
 lm.fit_mat 57.491 59.186  60.5674 59.268 61.745  65.147     5   a</code></pre>
</div>
</div>
<p>We’re splitting hairs at this point. I mean, what’s 20 microseconds between friends? And, yet, these 20 microseconds translate to a roughly 40% improvement in relative terms. As I keep saying, even microseconds add up once you multiply them by a couple thousand.</p>
<p>“Okay, Grant.” I can already you you saying. “You just told us to use data.tables and now you’re telling us to switch to matrices. Which is it, man?!” Well, remember what I said earlier about the enhanced structure that data.tables (and tibbles) offer us. We can easily create a list column of matrices inside a data.table (or tibble). We could have done this directly in the <code>gen_data()</code> function. But I’m going to leave that function as-is, and show you how simple it is to collapse columns of an existing data.table into a matrix list column. Once more we’ll use a standard grouped operation — where we are grouping by <code>sim</code> — to do the work:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> d[, </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>      .(<span class="at">Y =</span> <span class="fu">list</span>(y),</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">X_level =</span> <span class="fu">list</span>(<span class="fu">cbind</span>(<span class="at">intercept =</span> <span class="dv">1</span>, <span class="at">x1 =</span> x1, <span class="at">x2 =</span> x2, <span class="st">'x1:x2'</span> <span class="ot">=</span> x1_dmean<span class="sc">*</span>x2_dmean, <span class="at">id =</span> id)),</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">X_dmean =</span> <span class="fu">list</span>(<span class="fu">cbind</span>(<span class="at">intercept =</span> <span class="dv">1</span>, <span class="at">x1 =</span> x1_dmean, <span class="at">x2 =</span> x2_dmean, <span class="st">'x1:x2'</span> <span class="ot">=</span> x1_dmean<span class="sc">*</span>x2_dmean, <span class="at">id =</span> id))),</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>      by <span class="ot">=</span> sim]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     sim                                                               Y
   &lt;int&gt;                                                          &lt;list&gt;
1:     1 0.3716463,1.7366279,5.5578472,4.2280693,0.8833686,6.8554351,...
                                                                                                                                                                                                                                                                                                                                                                                                     X_level
                                                                                                                                                                                                                                                                                                                                                                                                      &lt;list&gt;
1:  1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 0.439524353, 0.769822511, 2.558708314, 1.070508391, 1.129287735, 2.715064987, 0.443725629, 0.729867467, 3.540728074, 1.938333259,-0.420055040, 4.755638443, 0.962260892, 0.352385931, 2.255598233,-0.004398437,-0.234929410, 4.528622182, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000,...
                                                                                                                                                                                                                                                                                                                                                                                                     X_dmean
                                                                                                                                                                                                                                                                                                                                                                                                      &lt;list&gt;
1:  1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000,-0.595066094,-0.264767937, 1.524117867, 0.035917944, 0.094697288, 1.680474539,-1.617065570,-1.330923731, 1.479936875,-0.122457940,-2.480846238, 2.694847244, 0.962260892, 0.352385931, 2.255598233,-0.004398437,-0.234929410, 4.528622182, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000, 1.000000000,...</code></pre>
</div>
</div>
<p>I know the printed output looks a little different, but the key thing to know is that each simulation is now represented by a single row. In this case, we only have one simulation, so our whole data table consists of just one row. Moreover, those fancy list columns contain all of the 500 panel observations — in matrix form — that we need run our regressions. To access whatever is inside one of the list columns, we “unnest” very simply by extracting the first element with brackets, i.e.&nbsp;<code>[[1]]</code>. For example, to extract the <code>Y</code> column of our single simulation dataset, we could do:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(d<span class="sc">$</span>Y[[<span class="dv">1</span>]]) <span class="do">## Just show the first few rows</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3716463 1.7366279 5.5578472 4.2280693 0.8833686 6.8554351</code></pre>
</div>
</div>
<p>If you’d like to know more about this approach, than I highly recommend Vincent’s aforementioned <a href="http://www.arelbundock.com/../datatable_nesting/">blog post</a> on the topic. The very last thing I’m going to show you here (since we’ll soon be adapting it to run our full simulation), is how easily everything carries over to operations <em>inside</em> a nested data table. In short, we just use the magic of <code>.SD</code> again:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>d[, <span class="fu">head</span>(.SD<span class="sc">$</span>Y[[<span class="dv">1</span>]]), by <span class="ot">=</span> sim]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     sim        V1
   &lt;int&gt;     &lt;num&gt;
1:     1 0.3716463
2:     1 1.7366279
3:     1 5.5578472
4:     1 4.2280693
5:     1 0.8833686
6:     1 6.8554351</code></pre>
</div>
</div>
</section>
<section id="putting-it-all-together" class="level2">
<h2 class="anchored" data-anchor-id="putting-it-all-together">Putting it all together</h2>
<p>Time to put everything together and run this thing. Like BS13, I’m going to simulate 20,000 runs. I’ll print the time it takes to complete the full simulation at the bottom.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="do">## Generate our large dataset of 20k simulations</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="fu">gen_data</span>(<span class="fl">2e4</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="do">## Optional: Set key for better collapse performance</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="fu">setkey</span>(d, sim)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="do">## Collapse into a nested data.table (1 row per simulation), with matrix list columns</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> d[, </span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>      .(<span class="at">Y =</span> <span class="fu">list</span>(y),</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">X_level =</span> <span class="fu">list</span>(<span class="fu">cbind</span>(<span class="at">intercept =</span> <span class="dv">1</span>, <span class="at">x1 =</span> x1, <span class="at">x2 =</span> x2, <span class="st">'x1:x2'</span> <span class="ot">=</span> x1<span class="sc">*</span>x2, <span class="at">id =</span> id)),</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">X_dmean =</span> <span class="fu">list</span>(<span class="fu">cbind</span>(<span class="at">intercept =</span> <span class="dv">1</span>, <span class="at">x1 =</span> x1_dmean, <span class="at">x2 =</span> x2_dmean, <span class="st">'x1:x2'</span> <span class="ot">=</span> x1_dmean<span class="sc">*</span>x2_dmean, <span class="at">id =</span> id))),</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>      by <span class="ot">=</span> sim]</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="do">## Run our simulation</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>tic <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>sims <span class="ot">=</span> d[, </span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>         .(<span class="at">level =</span> <span class="fu">coef</span>(<span class="fu">lm.fit</span>(.SD<span class="sc">$</span>X_level[[<span class="dv">1</span>]], .SD<span class="sc">$</span>Y[[<span class="dv">1</span>]]))[<span class="st">'x1:x2'</span>],</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>           <span class="at">dmean =</span> <span class="fu">coef</span>(<span class="fu">lm.fit</span>(.SD<span class="sc">$</span>X_dmean[[<span class="dv">1</span>]], .SD<span class="sc">$</span>Y[[<span class="dv">1</span>]]))[<span class="st">'x1:x2'</span>]), </span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>         by <span class="ot">=</span> sim]</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="fu">Sys.time</span>() <span class="sc">-</span> tic</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Time difference of 2.860526 secs</code></pre>
</div>
</div>
<p>And look at that. Just over 2 seconds to run the full 20k simulations! (Can you beat that? Let me know in the comments… <em>UPDATE: Turns out you can thanks to the even faster <code>.lm.fit()</code> function. See follow-up post <a href="../efficient-simulations-r-base-remix">here</a>.</em>)</p>
<p>All that hard work deserves a nice plot, don’t you think?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">family =</span> <span class="st">'HersheySans'</span>) <span class="do">## Optional: Nice font for (base) plotting</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(sims<span class="sc">$</span>level, <span class="at">col =</span> scales<span class="sc">::</span><span class="fu">alpha</span>(<span class="st">'skyblue'</span>, .<span class="dv">7</span>), <span class="at">border=</span><span class="cn">FALSE</span>,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">'Simulating interaction effects in panel data'</span>,</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>, <span class="fl">0.2</span>), </span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">'Coefficient values'</span>,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">sub =</span> <span class="st">'(True value is zero)'</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(sims<span class="sc">$</span>dmean, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">col =</span> scales<span class="sc">::</span><span class="fu">alpha</span>(<span class="st">'red'</span>, .<span class="dv">5</span>), <span class="at">border=</span><span class="cn">FALSE</span>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="dv">0</span>, <span class="at">lty =</span> <span class="dv">2</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="at">col =</span> <span class="fu">c</span>(scales<span class="sc">::</span><span class="fu">alpha</span>(<span class="fu">c</span>(<span class="st">'skyblue'</span>, <span class="st">'red'</span>), .<span class="dv">5</span>)), <span class="at">lwd =</span> <span class="dv">10</span>,</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>       <span class="at">legend =</span> <span class="fu">c</span>(<span class="st">"Level"</span>, <span class="st">"Demeaned"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/hist-1.png" class="img-fluid figure-img" width="2400"></p>
</figure>
</div>
</div>
</div>
<p>Here we have replicated the key result in BS13, Table 3. <strong>Moral of the story:</strong> If you have an interaction effect in a panel setting (e.g.&nbsp;DiD!), it’s always worth demeaning your terms and double-checking that your results don’t change.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Being able to write efficient simulation code is a very valuable skill. In this post we have replicated an actual published result, incorporating several principles that have served me well:</p>
<ol type="1">
<li><p><strong>Trim the fat</strong> (Subtitle: <code>lm.fit()</code> is your friend.)</p></li>
<li><p><strong>Generate your data once</strong> (Subtitle: It’s much quicker to generate one large dataset than many small ones)</p></li>
<li><p><strong>Go parallel or nest</strong> (Subtitle: Let data.table and co. handle the heavy lifting)</p></li>
<li><p><strong>Use matrices for an extra edge</strong> (Subtitle: Save your simulation from having to do extra conversion work)</p></li>
</ol>
<p>You certainly don’t have to adopt all of these principles to write your own efficient simulation code in R. There may even be cases where it’s more efficient to do something else. But I’m confident that incorporating at least one or two of them will generally make your simulations much faster.</p>
<p><strong>P.S.</strong> If you made it this far and still need convincing that simulations are awesome, watch John Rauser’s incredible talk, “<a href="https://www.youtube.com/watch?v=5Dnw46eC-0o"><em>Statistics Without The Agonizing Pain</em></a>”.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Balli, Hatice Ozer, and Bent E. Sørensen. “Interaction effects in econometrics.” Empirical Economics 45, no. 1 (2013): 583-603. <a href="https://www.uh.edu/~bsorense/Interaction_EE.pdf">Link</a></p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Ed Rubin and I are writing a <a href="https://github.com/grantmcdermott/ds4e">book</a> that will attempt to fill this gap, among other things. Stay tuned!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>In their notation, BS13 only demean the interacted terms on <span class="math inline">\(\beta_3\)</span>. But demeaning the parent terms on <span class="math inline">\(\beta_1\)</span> and <span class="math inline">\(\beta_2\)</span> is functionally equivalent and, as we shall see later, more convenient when writing the code since we can use R’s <code>*</code> expansion operator to concisely specify all of the terms.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Got a difference-in-differences model that uses twoway fixed-effects? Ya, that’s just an interaction term in a panel setting. In fact, the demeaning point that BS13 are making here — and actually draw an explicit comparison to later in the paper — is equivalent to the argument that we should control for unit-specific time trends in DiD models. The paper includes additional simulations demonstrating this equivalence, but I don’t want to get sidetracked by that here.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Another thing is that <code>lm.fit()</code> produces a much more limited, but leaner return object. We’ll be taxing our computer’s memory less as a result.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>That’s basically all that vectorisation is; i.e.&nbsp;a loop implemented at the C(++) level.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>This will closely mimic a <a href="https://rdatatable.gitlab.io/data.table/articles/datatable-sd-usage.html#grouped-regression-1">related example</a> in the data.table vignettes, which you should read if you’re interested to learn more.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/grantmcdermott\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>